#!/usr/bin/env python3
import datetime
import os
import threading
import time
from enum import Enum
from functools import partial
from typing import Tuple

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy

import isaac_sim_teleop_ros2.robot as robot
from geometry_msgs.msg import PointStamped, Pose, PoseArray, Twist
from isaac_sim_teleop_ros2.img_latency_manager import ImgLatencyManager
from isaac_sim_teleop_ros2.monitoring import Monitoring
from isaac_sim_teleop_ros2.state import ControlState
from nav_msgs.msg import Odometry
from rosgraph_msgs.msg import Clock
from sensor_msgs.msg import Joy, TimeReference
from std_msgs.msg import Bool, Header, String

MAX_LINEAR_VEL_LEVEL_DT = 0.1

# Control status constants
CONTROL_STATUS_MODEL = "model"


class Button(Enum):
    BTN_A = 0
    BTN_B = 1
    BTN_X = 2
    BTN_Y = 3
    BTN_LB = 4
    BTN_RB = 5
    BTN_LSB = 9
    BTN_RSB = 10


AXIS_LINEAR = 4
AXIS_ANGULAR = 0
AXIS_RT = 5  # Right Trigger

REAL_TIME_WINDOW = 20
RATE = 20


def change_max_linear_vel(state: ControlState, dv: int, dt: float, stop_event: threading.Event, robot: robot.Robot):
    is_first = True
    while not stop_event.is_set():
        state.linear_vel_level = min(max(1, state.linear_vel_level + dv), robot.get_max_linear_vel_level())
        robot.set_max_linear_vel(state.linear_vel_level)
        if is_first:
            time.sleep(3 * dt)
            is_first = False
        else:
            time.sleep(dt)


class TeleopNode(Node):
    def __init__(self):
        super().__init__('isaac_sim_teleop_node')
        
        # Declare parameters
        self.declare_parameter('frame_id', 'teleop')
        self.declare_parameter('use_teleport', True)
        self.declare_parameter('use_clock', False)
        self.declare_parameter('use_people_pose', True)
        self.declare_parameter('use_wheel_odom', False)
        self.declare_parameter('auto_restart_on_collision', True)
        self.declare_parameter('use_control_topic', False)
        self.declare_parameter('img_list', '')
        self.declare_parameter('control_report_timeout', 1.0)
        
        # Get parameters
        self.frame_id = self.get_parameter('frame_id').value
        use_teleport = self.get_parameter('use_teleport').value
        use_clock = self.get_parameter('use_clock').value
        use_people_pose = self.get_parameter('use_people_pose').value
        use_wheel_odom = self.get_parameter('use_wheel_odom').value
        auto_restart_on_collision = self.get_parameter('auto_restart_on_collision').value
        self.use_control_topic = self.get_parameter('use_control_topic').value
        img_list = self.get_parameter('img_list').value
        self.control_report_timeout = self.get_parameter('control_report_timeout').value
        
        # Initialize robot
        sim_robot = os.environ.get("SIM_ROBOT")
        if sim_robot == "nova_carter":
            self.sim_robot = robot.NovaCarter()
        elif sim_robot == "segway_e1":
            self.sim_robot = robot.SegwayE1()
        else:
            raise ValueError(
                "Unknown robot: {robot}. Set SIM_ROBOT to 'nova_carter' or 'segway_e1'.".format(
                    robot=sim_robot
                )
            )
        
        self.control_state = ControlState()
        
        # QoS profile for best effort
        qos_profile = QoSProfile(
            reliability=ReliabilityPolicy.BEST_EFFORT,
            history=HistoryPolicy.KEEP_LAST,
            depth=10
        )
        
        # Publishers
        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 1)
        self.is_model_pub = self.create_publisher(Bool, '/is_model', 1)
        
        # Optional publishers
        self.robot_pose_pub = None
        if use_teleport:
            self.robot_pose_pub = self.create_publisher(Pose, '/robot_pose', 1)
            self.create_subscription(Bool, '/start_record', self.callback_start_record, 1)
            if auto_restart_on_collision:
                self.create_subscription(PointStamped, '/collision_event', self.callback_collision_event, 10)
        
        self.control_request_pub = None
        if self.use_control_topic:
            self.control_request_pub = self.create_publisher(Bool, '/control_request', 1)
            self.create_subscription(String, '/control_report', self.callback_control_report, 10)
        
        # Subscribers
        odom_topic_name = '/odom'
        self.odom_latency_pub = self.create_publisher(TimeReference, f"{odom_topic_name}/latency", 10)
        self.create_subscription(Odometry, '/odom', self.callback_odom, 10)

        if use_clock:
            self.create_subscription(Clock, '/clock', self.callback_clock, 1)

        if use_people_pose:
            self.create_subscription(PoseArray, '/people_pose', self.callback_people_pose, 1)

        if use_wheel_odom:
            self.create_subscription(Odometry, '/wheel_odom', self.callback_wheel_odom, 10)

        self.create_subscription(Twist, '/cmd_vel_model', self.callback_cmd_vel_model, 10)
        self.create_subscription(Joy, '/joy', self.callback_joy, 10)

        # Image latency managers
        img_list = img_list.split(",") if img_list else []
        self.img_latency_manager_list = [ImgLatencyManager(img, self.frame_id, self) for img in img_list]

        # Monitoring
        self.monitoring = Monitoring(self.sim_robot, use_clock, self.use_control_topic, self.frame_id)

        # Timer for main loop
        self.timer = self.create_timer(1.0 / RATE, self.timer_callback)
        self.count = 0
        self.last_time = None

    def callback_joy(self, data: Joy):
        # decrease max linear velocity
        if self.control_state.previous_btn_lb != data.buttons[Button.BTN_LB.value]:
            if data.buttons[Button.BTN_LB.value] and self.control_state.thread_stop_lb is None:
                self.control_state.thread_stop_lb = threading.Event()
                interval_thread = threading.Thread(
                    target=change_max_linear_vel,
                    args=(self.control_state, -1, MAX_LINEAR_VEL_LEVEL_DT, self.control_state.thread_stop_lb, self.sim_robot)
                )
                interval_thread.start()
            else:
                if self.control_state.thread_stop_lb is not None:
                    self.control_state.thread_stop_lb.set()
                self.control_state.thread_stop_lb = None
            self.control_state.previous_btn_lb = data.buttons[Button.BTN_LB.value]

        # increase max linear velocity
        if self.control_state.previous_btn_rb != data.buttons[Button.BTN_RB.value]:
            if data.buttons[Button.BTN_RB.value] and self.control_state.thread_stop_rb is None:
                self.control_state.thread_stop_rb = threading.Event()
                interval_thread = threading.Thread(
                    target=change_max_linear_vel,
                    args=(self.control_state, +1, MAX_LINEAR_VEL_LEVEL_DT, self.control_state.thread_stop_rb, self.sim_robot)
                )
                interval_thread.start()
            else:
                if self.control_state.thread_stop_rb is not None:
                    self.control_state.thread_stop_rb.set()
                self.control_state.thread_stop_rb = None
            self.control_state.previous_btn_rb = data.buttons[Button.BTN_RB.value]

        # linear rate lock
        if self.control_state.previous_btn_rsb != data.buttons[Button.BTN_RSB.value]:
            if data.buttons[Button.BTN_RSB.value]:
                self.control_state.linear_rate_lock = not self.control_state.linear_rate_lock
            self.control_state.previous_btn_rsb = data.buttons[Button.BTN_RSB.value]

        # emergency stop
        if self.control_state.previous_btn_lsb != data.buttons[Button.BTN_LSB.value]:
            if data.buttons[Button.BTN_LSB.value]:
                self.control_state.cml_vel_lock = not self.control_state.cml_vel_lock
            self.control_state.previous_btn_lsb = data.buttons[Button.BTN_LSB.value]

        if self.robot_pose_pub is not None:
            # teleport to previous pose
            if self.control_state.previous_btn_x != data.buttons[Button.BTN_X.value]:
                if data.buttons[Button.BTN_X.value]:
                    if self.control_state.previous_pose is not None:
                        self.robot_pose_pub.publish(self.control_state.previous_pose)
                self.control_state.previous_btn_x = data.buttons[Button.BTN_X.value]

            # teleport to initial pose
            if self.control_state.previous_btn_y != data.buttons[Button.BTN_Y.value]:
                if data.buttons[Button.BTN_Y.value]:
                    robot_pose = Pose()
                    robot_pose.orientation.w = 1.0
                    self.robot_pose_pub.publish(robot_pose)
                self.control_state.previous_btn_y = data.buttons[Button.BTN_Y.value]

        # Model input switch (RT - Right Trigger)
        current_axis_rt = data.axes[AXIS_RT]
        if self.control_state.previous_axis_rt >= 0.0 and current_axis_rt < 0.0:
            if self.use_control_topic and self.control_request_pub is not None:
                request_release = self.control_state.control_report_status == self.frame_id
                msg = Bool()
                msg.data = not request_release
                self.control_request_pub.publish(msg)
            else:
                self.control_state.model_input_switch = not self.control_state.model_input_switch
        self.control_state.previous_axis_rt = current_axis_rt

        if self.control_state.cml_vel_lock:
            self.control_state.linear_rate = 0.0
            self.control_state.angular_rate = 0.0
        else:
            if not self.control_state.linear_rate_lock:
                self.control_state.linear_rate = data.axes[AXIS_LINEAR]
            self.control_state.angular_rate = data.axes[AXIS_ANGULAR]

        # handle action
        self.control_state.action_state_dict = self.sim_robot.handle_action(data)

    def callback_start_record(self, data: Bool):
        self.control_state.previous_pose = self.control_state.current_pose

    def callback_odom(self, data: Odometry):
        self.control_state.odom_header = data.header
        self.control_state.current_pose = data.pose.pose
        if not self.get_parameter('use_wheel_odom').value:
            self.control_state.twist = data.twist.twist

        latency = TimeReference()
        latency.header = Header()
        latency.header.stamp = self.get_clock().now().to_msg()
        latency.header.frame_id = self.frame_id
        latency.time_ref = data.header.stamp
        latency.source = '/odom'
        self.odom_latency_pub.publish(latency)

    def callback_wheel_odom(self, data: Odometry):
        self.control_state.twist = data.twist.twist

    def callback_people_pose(self, data: PoseArray):
        self.control_state.people_pose = data

    def callback_cmd_vel_model(self, data: Twist):
        self.control_state.model_cmd = data

    def callback_clock(self, data: Clock):
        real_time = time.time()

        self.control_state.real_time_list.append(real_time - self.control_state.real_time)
        self.control_state.real_time = real_time

        real_time_cnt = len(self.control_state.real_time_list)
        self.control_state.current_fps = f"{real_time_cnt / sum(self.control_state.real_time_list):.1f}"
        if REAL_TIME_WINDOW <= real_time_cnt:
            for _ in range(real_time_cnt - REAL_TIME_WINDOW + 1):
                self.control_state.real_time_list.pop(0)

        time_sec = data.clock.sec + data.clock.nanosec * 1e-9
        self.control_state.curreunt_time = datetime.datetime.fromtimestamp(time_sec).strftime("%H:%M:%S")

    def callback_collision_event(self, data: PointStamped):
        self.control_state.is_collision_detected = True

    def callback_control_report(self, data: String):
        self.control_state.control_report_status = data.data
        self.control_state.last_control_report_time = time.time()

    def _create_stop_command(self, current_time, is_model: bool) -> Tuple[bool, Twist, bool]:
        """Create a stop command (all zeros)."""
        twist = Twist()
        return (True, twist, is_model)

    def _create_teleop_command(self, current_time) -> Tuple[bool, Twist, bool]:
        """Create a teleop command based on current joystick state."""
        twist = self.sim_robot.compute_cmd_vel(
            self.control_state.linear_rate,
            self.control_state.angular_rate,
            self.control_state.twist
        )
        return (True, twist, False)

    def get_publish_info(self, current_time) -> Tuple[bool, Twist, bool]:
        """
        Returns (should_publish, cmd_vel, is_model_value)
        should_publish: whether to publish cmd_vel and is_model
        cmd_vel: Twist to publish
        is_model_value: value for /is_model topic
        """
        # Legacy mode
        if not self.use_control_topic:
            if self.control_state.model_input_switch:
                return (True, self.control_state.model_cmd, True)
            return self._create_teleop_command(current_time)

        # Control topic mode
        status = self.control_state.control_report_status

        # Handle timeout
        if self.control_state.control_report_timeout_detected:
            if status == self.frame_id:
                return self._create_stop_command(current_time, False)
            if status == CONTROL_STATUS_MODEL:
                return self._create_stop_command(current_time, True)
            return (False, Twist(), False)

        # Normal operation
        if status == self.frame_id:
            return self._create_teleop_command(current_time)
        if status == CONTROL_STATUS_MODEL:
            return (True, self.control_state.model_cmd, True)

        return (False, Twist(), False)

    def timer_callback(self):
        current_time = self.get_clock().now().to_msg()
        if current_time == self.last_time:
            return
        self.last_time = current_time

        if self.use_control_topic and self.control_state.last_control_report_time > 0:
            time_since_last_report = time.time() - self.control_state.last_control_report_time
            self.control_state.control_report_timeout_detected = time_since_last_report > self.control_report_timeout

        # Publish cmd_vel and /is_model
        should_pub, cmd_vel, is_model_value = self.get_publish_info(current_time)
        if should_pub:
            self.cmd_vel_pub.publish(cmd_vel)
            msg = Bool()
            msg.data = is_model_value
            self.is_model_pub.publish(msg)

        if self.count == 1:
            self.monitoring.log(self.control_state)
            self.count = 0
        self.count += 1

        if self.control_state.is_collision_detected:
            self.control_state.is_collision_detected = False
            is_stop = abs(self.control_state.twist.linear.x) < 0.01 and abs(self.control_state.twist.angular.z) < 0.01
            if not is_stop and self.control_state.previous_pose is not None and self.robot_pose_pub is not None:
                self.robot_pose_pub.publish(self.control_state.previous_pose)

    def cleanup(self):
        self.cmd_vel_pub.publish(Twist())
        self.monitoring.close()
        self.get_logger().info("teleop end")


def main(args=None):
    rclpy.init(args=args)

    try:
        node = TeleopNode()
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    except Exception as e:
        print(f"Error: {e}")
    finally:
        if 'node' in locals():
            node.cleanup()
            node.destroy_node()
        rclpy.shutdown()


if __name__ == "__main__":
    main()

